trigger:
- main

variables:
  # Docker hub images
  frontendImage: 'jyothika2832/billing-backend:latest'
  backendImage: 'jyothika2832/billing-frontend:latest'
  mysqlImage: 'mysql:5.7'
  # Azure resources
  azureSubscription: 'azure-resource-manager-service-connection'
  kubernetesServiceConnection: 'my-aks-connection'
  resourceGroup: 'practise-rg'
  aksCluster: 'my-aks-cluster'
  location: 'eastus'
  namespace: 'production'
  nodeCount: 2
  vmSize: 'Standard_B2s'

pool:
  vmImage: ubuntu-latest

stages:
  - stage: Provision_AKS
    displayName: 'Provision AKS Cluster'
    jobs:
      - job: Create_Cluster
        steps:
        - task: AzureCLI@2
          displayName: 'Create Resource Group'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az group create \
                --name $(resourceGroup) \
                --location $(location)
        
        - task: AzureCLI@2
          displayName: 'Create or Update AKS Cluster'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              # Check if cluster exists
              if az aks show --resource-group $(resourceGroup) --name $(aksCluster) --query name -o tsv 2>/dev/null; then
                echo "Cluster exists - checking current node count..."
                CURRENT_NODES=$(az aks show \
                  --resource-group $(resourceGroup) \
                  --name $(aksCluster) \
                  --query agentPoolProfiles[0].count -o tsv)
                
                if [ "$CURRENT_NODES" -ne $(nodeCount) ]; then
                  echo "Scaling node pool from $CURRENT_NODES to $(nodeCount)..."
                  az aks nodepool scale \
                    --resource-group $(resourceGroup) \
                    --cluster-name $(aksCluster) \
                    --name nodepool1 \
                    --node-count $(nodeCount)
                else
                  echo "Node count already matches desired count ($(nodeCount)) - no scaling needed"
                fi
              else
                echo "Cluster does not exist - creating..."
                az aks create \
                  --resource-group $(resourceGroup) \
                  --name $(aksCluster) \
                  --node-count $(nodeCount) \
                  --node-vm-size $(vmSize) \
                  --enable-addons monitoring \
                  --generate-ssh-keys \
                  --location $(location)
              fi

  - stage: Configure_Kubernetes
    displayName: 'Configure Kubernetes Access'
    dependsOn: Provision_AKS
    jobs:
    - job: Configure
      steps:
        - task: KubectlInstaller@0
          displayName: 'Install kubectl'

        - task: AzureCLI@2
          displayName: 'Get AKS Credentials'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              # Create kubeconfig directory
              mkdir -p $(Pipeline.Workspace)/kube
              
              # Get credentials with admin access
              az aks get-credentials \
                --resource-group $(resourceGroup) \
                --name $(aksCluster) \
                --overwrite-existing \
                --file $(Pipeline.Workspace)/kube/config \
                --admin
              
              # Set KUBECONFIG environment variable
              echo "##vso[task.setvariable variable=KUBECONFIG]$(Pipeline.Workspace)/kube/config"

        - task: Bash@3
          displayName: 'Verify Cluster Access'
          inputs:
            targetType: 'inline'
            script: |
              # Verify kubeconfig exists
              ls -la $(Pipeline.Workspace)/kube/config
              
              # Set context explicitly
              kubectl config use-context "$(aksCluster)-admin"
              
              # Verify cluster access
              kubectl config current-context
              kubectl cluster-info
              kubectl get nodes

  - stage: Deploy_Application
    displayName: 'Deploy Application'
    dependsOn: Configure_Kubernetes
    jobs:
    - job: Deploy
      steps:
        - task: Kubernetes@1
          displayName: 'Create Namespace'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            command: 'apply'
            useConfigurationFile: true
            configuration: |
              apiVersion: v1
              kind: Namespace
              metadata:
                name: $(namespace)

        - task: Kubernetes@1
          displayName: 'Create MySQL secrets'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            command: 'apply'
            useConfigurationFile: true
            configuration: |
              apiVersion: v1
              kind: Secret
              metadata:
                name: mysql-secrets
                namespace: $(namespace)
              type: Opaque
              stringData:
                root-password: your-root-password
                username: your-db-user
                password: your-db-password

        - task: KubernetesManifest@1
          displayName: 'Deploy MySQL'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            action: 'deploy'
            namespace: $(namespace)
            manifests: |
              $(System.DefaultWorkingDirectory)/manifests/mysql-deployment.yaml
              $(System.DefaultWorkingDirectory)/manifests/mysql-service.yaml

        - task: Bash@3
          displayName: 'Wait for MySQL'
          inputs:
            targetType: 'inline'
            script: |
              kubectl wait --namespace $(namespace) --for=condition=ready pod -l app=mysql --timeout=300s

        - task: KubernetesManifest@1
          displayName: 'Deploy Backend'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            action: 'deploy'
            namespace: $(namespace)
            manifests: |
              $(System.DefaultWorkingDirectory)/manifests/backend-deployment.yaml
              $(System.DefaultWorkingDirectory)/manifests/backend-service.yaml

        - task: KubernetesManifest@1
          displayName: 'Deploy Frontend'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            action: 'deploy'
            namespace: $(namespace)
            manifests: |
              $(System.DefaultWorkingDirectory)/manifests/frontend-deployment.yaml
              $(System.DefaultWorkingDirectory)/manifests/frontend-service.yaml

        - task: Bash@3
          displayName: 'Get Frontend URL'
          inputs:
            targetType: 'inline'
            script: |
              echo "##vso[task.setvariable variable=frontendUrl]http://$(kubectl get svc frontend -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
              echo "Access your application at: http://$(kubectl get svc frontend -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
