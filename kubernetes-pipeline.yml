trigger:
- main

variables:
  # Docker hub images
  frontendImage: 'jyothika2832/billing-backend:latest'
  backendImage: 'jyothika2832/billing-frontend:latest'
  mysqlImage: 'mysql:5.7'
  # Azure resources
  azureSubscription: 'azure-resource-manager-service-connection'
  kubernetesServiceConnection: 'my-aks-connection'
  resourceGroup: 'practise-rg'
  aksCluster: 'my-aks-cluster'
  location: 'eastus'
  namespace: 'production'
  nodeCount: 2
  vmSize: 'Standard_B2s'

pool:
  vmImage: ubuntu-latest

stages:
  - stage: Provision_AKS
    displayName: 'Provision AKS Cluster'
    jobs:
      - job: Create_Cluster
        steps:
        - task: AzureCLI@2
          displayName: 'Create Resource Group'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az group create \
                --name $(resourceGroup) \
                --location $(location)
        
        - task: AzureCLI@2
          displayName: 'Create or Update AKS Cluster'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              # Check if cluster exists
              if az aks show --resource-group $(resourceGroup) --name $(aksCluster) --query name -o tsv 2>/dev/null; then
                echo "Cluster exists - scaling node pool..."
                # To update node count, we need to scale the node pool
                az aks nodepool scale \
                  --resource-group $(resourceGroup) \
                  --cluster-name $(aksCluster) \
                  --name nodepool1 \
                  --node-count $(nodeCount)
              else
                echo "Cluster does not exist - creating..."
                az aks create \
                  --resource-group $(resourceGroup) \
                  --name $(aksCluster) \
                  --node-count $(nodeCount) \
                  --node-vm-size $(vmSize) \
                  --enable-addons monitoring \
                  --generate-ssh-keys \
                  --location $(location)
              fi
              
              # Get credentials and store as artifact
              mkdir -p $(Pipeline.Workspace)/kube
              az aks get-credentials \
                --resource-group $(resourceGroup) \
                --name $(aksCluster) \
                --overwrite-existing \
                --file $(Pipeline.Workspace)/kube/config
              
              # Verify the file exists
              ls -la $(Pipeline.Workspace)/kube
              cat $(Pipeline.Workspace)/kube/config

        - task: PublishPipelineArtifact@1
          displayName: 'Publish kubeconfig'
          inputs:
            targetPath: '$(Pipeline.Workspace)/kube'
            artifactName: 'kubeconfig'
            publishLocation: 'pipeline'

  - stage: Configure_Kubernetes
    displayName: 'Configure Kubernetes Access'
    dependsOn: Provision_AKS
    jobs:
    - job: Configure
      steps:
        - task: DownloadPipelineArtifact@2
          displayName: 'Download kubeconfig'
          inputs:
            artifact: 'kubeconfig'
            path: '$(Pipeline.Workspace)/kube'

        - task: KubectlInstaller@0
          displayName: 'Install kubectl'

        - task: Bash@3
          displayName: 'Verify Cluster Access'
          inputs:
            targetType: 'inline'
            script: |
              mkdir -p ~/.kube
              cp $(Pipeline.Workspace)/kube/config ~/.kube/config
              chmod 600 ~/.kube/config
              kubectl config current-context
              kubectl cluster-info

        - task: Bash@3
          displayName: 'Create Namespace'
          inputs:
            targetType: 'inline'
            script: |
              kubectl apply -f - <<EOF
              apiVersion: v1
              kind: Namespace
              metadata:
                name: $(namespace)
              EOF

  - stage: Deploy_Application
    displayName: 'Deploy Application'
    dependsOn: Configure_Kubernetes
    jobs:
    - job: Deploy
      steps:
        - task: Bash@3
          displayName: 'Create MySQL secrets'
          inputs:
            targetType: 'inline'
            script: |
              kubectl apply -f - <<EOF
              apiVersion: v1
              kind: Secret
              metadata:
                name: mysql-secrets
                namespace: $(namespace)
              type: Opaque
              data:
                root-password: $(echo -n 'your-root-password' | base64 -w0)
                username: $(echo -n 'your-db-user' | base64 -w0)
                password: $(echo -n 'your-db-password' | base64 -w0)
              EOF

        - task: KubernetesManifest@1
          displayName: 'Deploy MySQL'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            action: 'deploy'
            namespace: $(namespace)
            manifests: |
              $(System.DefaultWorkingDirectory)/manifests/mysql-deployment.yaml
              $(System.DefaultWorkingDirectory)/manifests/mysql-service.yaml

        - task: Bash@3
          displayName: 'Wait for MySQL'
          inputs:
            targetType: 'inline'
            script: |
              kubectl wait --namespace $(namespace) --for=condition=ready pod -l app=mysql --timeout=300s

        - task: KubernetesManifest@1
          displayName: 'Deploy Backend'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            action: 'deploy'
            namespace: $(namespace)
            manifests: |
              $(System.DefaultWorkingDirectory)/manifests/backend-deployment.yaml
              $(System.DefaultWorkingDirectory)/manifests/backend-service.yaml

        - task: KubernetesManifest@1
          displayName: 'Deploy Frontend'
          inputs:
            kubernetesServiceEndpoint: $(kubernetesServiceConnection)
            action: 'deploy'
            namespace: $(namespace)
            manifests: |
              $(System.DefaultWorkingDirectory)/manifests/frontend-deployment.yaml
              $(System.DefaultWorkingDirectory)/manifests/frontend-service.yaml

        - task: Bash@3
          displayName: 'Get Frontend URL'
          inputs:
            targetType: 'inline'
            script: |
              echo "##vso[task.setvariable variable=frontendUrl]http://$(kubectl get svc frontend -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
              echo "Access your application at: http://$(kubectl get svc frontend -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
